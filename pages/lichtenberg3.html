---
permalink: /fun/lichtenberg3/
---
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Lichtenberg- Click Around!</title>
    <meta name="viewport" content="width=device-width, height=device-height initial-scale=1">
    <style>html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; } canvas { display: block; }</style>
</head>
<body>
<canvas id="lichtenberg"></canvas>
<script>
    var width  = Math.floor(window.innerWidth);
    var height = Math.floor(window.innerHeight);
    var rows   = 250;
    var cols   = Math.round(rows * width / height);
    var pbase  = 0;
    var pFact  = 2;
    var N      = rows * cols;

    var cellW = width  / cols;
    var cellH = height / rows;

    var canvas = document.getElementById('lichtenberg');
    canvas.width  = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');

    // Static p values
    var p = new Float32Array(N);
    for (var i = 0; i < N; i++) {
        p[i] = pbase + pFact * (1 - pbase) * Math.random();
    }

    // Initial render via ImageData
    var pmax   = pbase + 0.1 * (1 - pbase);
    var imgData = ctx.createImageData(width, height);
    var px = imgData.data;
    for (var r = 0; r < rows; r++) {
        var canvasY0 = Math.floor((rows - 1 - r) * cellH);
        var canvasY1 = Math.floor((rows - r) * cellH);
        for (var c = 0; c < cols; c++) {
            var v = Math.round(255 * (1 - Math.min(1, p[r * cols + c] / pmax)));
            var x0 = Math.floor(c * cellW);
            var x1 = Math.floor((c + 1) * cellW);
            for (var py = canvasY0; py < canvasY1; py++) {
                for (var pxi = x0; pxi < x1; pxi++) {
                    var pi = (py * width + pxi) * 4;
                    px[pi] = px[pi+1] = px[pi+2] = v;
                    px[pi+3] = 255;
                }
            }
        }
    }
    ctx.putImageData(imgData, 0, 0);

    function fillCell(row, col, r, g, b) {
        ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
        ctx.fillRect(Math.floor(col * cellW), Math.floor((rows - 1 - row) * cellH),
                     Math.ceil(cellW), Math.ceil(cellH));
    }

    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

    async function find_paths(event) {
        // Per-click typed arrays â€” much faster than JSON deep copy
        var cost   = new Float32Array(N).fill(Infinity);
        var used   = new Uint8Array(N);      // 0=unseen, 1=discovered
        var parent = new Int32Array(N).fill(-1);
        var md     = new Int32Array(N);

        var ex  = event.clientX;
        var ey  = event.clientY;
        var row = 1 + rows - Math.round(ey / (height / rows));
        var col = -2 + Math.round(ex / (width / cols));
        var ind = row * cols + col;

        cost[ind] = 0;
        used[ind] = 1;
        md[ind]   = 0;
        fillCell(row, col, 255, 255, 0); // yellow source

        // Random destinations
        var n = Math.floor(1 + 12 * Math.random());
        var destinations = new Int32Array(n);
        var maxMd = 0;
        for (var i = 0; i < n; i++) {
            var rind = Math.round((N - 1) * Math.random());
            destinations[i] = rind;
            var dm = Math.abs(Math.floor(rind / cols) - row) + Math.abs((rind % cols) - col);
            if (dm > maxMd) maxMd = dm;
        }

        var actives    = [ind];
        var newActives = [];

        for (var i = 0; i < maxMd; i++) {
            var len = actives.length;
            for (var ai = 0; ai < len; ai++) {
                var active = actives[ai];
                var ar = Math.floor(active / cols);
                var ac = active % cols;
                // boundary check to avoid wrap-around
                if (ar <= 0 || ar >= rows - 1 || ac <= 0 || ac >= cols - 1) continue;
                var activeCost = cost[active];
                var neighbors = [
                    ar * cols + ac - 1,       ar * cols + ac + 1,
                    (ar - 1) * cols + ac,     (ar + 1) * cols + ac,
                    (ar - 1) * cols + ac - 1, (ar + 1) * cols + ac - 1,
                    (ar - 1) * cols + ac + 1, (ar + 1) * cols + ac + 1
                ];
                for (var n2 = 0; n2 < 8; n2++) {
                    var idx = neighbors[n2];
                    if (used[idx] === 0) {
                        used[idx] = 1;
                        md[idx] = Math.abs(Math.floor(idx / cols) - row) + Math.abs((idx % cols) - col);
                        actives.push(idx);
                    }
                    var newCost = activeCost + p[idx];
                    if (newCost < cost[idx]) {
                        cost[idx]   = newCost;
                        parent[idx] = active;
                    }
                }
            }
            // Filter: keep only cells where i < 1.2 * md
            newActives.length = 0;
            for (var ai = 0; ai < actives.length; ai++) {
                if (i < 1.2 * md[actives[ai]]) {
                    newActives.push(actives[ai]);
                }
            }
            actives = newActives;
            newActives = [];
        }

        // Reconstruct and animate paths via parent backtracking
        for (var di = 0; di < destinations.length; di++) {
            // Build path by backtracking from destination to source
            var path = [];
            var cur  = destinations[di];
            while (cur !== -1 && cur !== ind) {
                path.push(cur);
                cur = parent[cur];
            }
            path.reverse();
            plotPath(path); // fire-and-forget async
        }
    }

    async function plotPath(path) {
        for (var i = 0; i < path.length; i++) {
            var idx = path[i];
            fillCell(Math.floor(idx / cols), idx % cols, 255, 255, 0);
            await delay(1);
        }
    }

    document.addEventListener('click', find_paths);
</script>
</body>
</html>