---
permalink: /fun/lichtenberg2/
---
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Lichtenberg- Click Around!</title>
    <meta name="viewport" content="width=device-width, height=device-height initial-scale=1">
    <style>html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; } canvas { display: block; }</style>
</head>
<body>
<canvas id="lichtenberg"></canvas>
<script>
    var width  = Math.floor(window.innerWidth);
    var height = Math.floor(window.innerHeight);
    var rows   = 200;
    var cols   = Math.round(rows * width / height);
    var pbase  = 0;
    var pFact  = 2;

    var cellW = width  / cols;
    var cellH = height / rows;
    var N     = rows * cols;

    var canvas = document.getElementById('lichtenberg');
    canvas.width  = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');

    // Static per-cell p values
    var p = new Float32Array(N);
    for (var i = 0; i < N; i++) {
        p[i] = pbase + pFact * (1 - pbase) * Math.random();
    }

    // Initial render via ImageData
    var imgData = ctx.createImageData(width, height);
    var px = imgData.data;
    for (var r = 0; r < rows; r++) {
        var canvasY0 = Math.floor((rows - 1 - r) * cellH);
        var canvasY1 = Math.floor((rows - r) * cellH);
        for (var c = 0; c < cols; c++) {
            // myColor: domain [0,1] white->black; p[i] in [0,2) — clamp to 1
            var v = Math.round(255 * (1 - Math.min(1, p[r * cols + c])));
            var x0 = Math.floor(c * cellW);
            var x1 = Math.floor((c + 1) * cellW);
            for (var py = canvasY0; py < canvasY1; py++) {
                for (var pxi = x0; pxi < x1; pxi++) {
                    var pi = (py * width + pxi) * 4;
                    px[pi] = px[pi+1] = px[pi+2] = v;
                    px[pi+3] = 255;
                }
            }
        }
    }
    ctx.putImageData(imgData, 0, 0);

    function fillCell(row, col, r, g, b) {
        ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
        ctx.fillRect(Math.floor(col * cellW), Math.floor((rows - 1 - row) * cellH),
                     Math.ceil(cellW), Math.ceil(cellH));
    }

    // pathColor: domain [0, 15^2] white->black
    function pathColorVal(cost) {
        return Math.round(255 * (1 - Math.min(1, (cost * cost) / 225)));
    }

    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

    // Persistent cost array — never reset between clicks so old pulse structure is preserved
    var cost = new Float32Array(N).fill(Infinity);

    async function find_paths(event) {
        // Per-click transient state
        var used   = new Uint8Array(N);
        var parent = new Int32Array(N).fill(-1);
        var md     = new Int32Array(N).fill(0);

        var ex  = event.clientX;
        var ey  = event.clientY;
        var row = 1 + rows - Math.round(ey / (height / rows));
        var col = -2 + Math.round(ex / (width / cols));
        var ind = row * cols + col;

        cost[ind] = 0;
        used[ind] = 1;
        md[ind]   = 0;

        // Pick a random destination
        var rind = Math.round((N - 1) * Math.round(Math.random()));
        var srcRow = row, srcCol = col;
        var destMd = Math.abs(Math.floor(rind / cols) - srcRow) + Math.abs((rind % cols) - srcCol);

        var actives    = [ind];
        var newActives = [];

        for (var i = 0; i < 2 * destMd; i++) {
            var len = actives.length;
            for (var ai = 0; ai < len; ai++) {
                var active = actives[ai];
                var ar = Math.floor(active / cols);
                var ac = active % cols;
                var activeCost = cost[active];
                // 8-directional neighbors
                var neighbors = [
                    ar * cols + ac - 1,       ar * cols + ac + 1,
                    (ar - 1) * cols + ac,     (ar + 1) * cols + ac,
                    (ar - 1) * cols + ac - 1, (ar + 1) * cols + ac - 1,
                    (ar - 1) * cols + ac + 1, (ar + 1) * cols + ac + 1
                ];
                for (var n = 0; n < 8; n++) {
                    var idx = neighbors[n];
                    if (idx >= 0 && idx < N) {
                        if (used[idx] === 0) {
                            used[idx] = 1;
                            md[idx] = Math.abs(Math.floor(idx / cols) - srcRow) + Math.abs((idx % cols) - srcCol);
                            actives.push(idx);
                        }
                        var newCost = activeCost + p[idx];
                        if (newCost < cost[idx]) {
                            cost[idx] = newCost;
                            parent[idx] = active;
                            var v = pathColorVal(newCost);
                            fillCell(Math.floor(idx / cols), idx % cols, v, v, v);
                        }
                    }
                }
            }
            // Remove cells where i >= 10 + 1.2 * their md
            newActives.length = 0;
            for (var ai = 0; ai < actives.length; ai++) {
                if (i < 10 + 1.2 * md[actives[ai]]) {
                    newActives.push(actives[ai]);
                }
            }
            actives = newActives;
            newActives = [];
            if ((i % 5) === 0) { await delay(1); }
        }
    }

    document.addEventListener('click', find_paths);
</script>
</body>
</html>